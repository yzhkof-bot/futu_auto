"""
Advanced backtesting engine with Kelly Criterion integration and realistic execution modeling.
Enhanced version of the backtest logic from backtest_nvda.py.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

from ..strategies.base_strategy import BaseStrategy, StrategySignal, SignalType

@dataclass
class Trade:
    """Data class representing a completed trade."""
    entry_time: pd.Timestamp
    exit_time: pd.Timestamp
    symbol: str
    side: str  # 'long' or 'short'
    entry_price: float
    exit_price: float
    quantity: float
    pnl: float
    pnl_pct: float
    commission: float
    slippage: float
    holding_period: int  # days
    exit_reason: str
    metadata: Optional[Dict] = None

@dataclass
class Position:
    """Data class representing an open position."""
    symbol: str
    side: str
    quantity: float
    entry_price: float
    entry_time: pd.Timestamp
    current_price: float
    unrealized_pnl: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Optional[Dict] = None

class BacktestEngine:
    """
    Professional backtesting engine with realistic execution modeling.
    
    Features:
    - Kelly Criterion position sizing
    - Realistic slippage and commission modeling
    - Multiple order types (market, limit)
    - Portfolio-level risk management
    - Detailed trade tracking and analysis
    """
    
    def __init__(self,
                 initial_capital: float = 100000,
                 commission_rate: float = 0.001,
                 slippage_rate: float = 0.0005,
                 max_position_size: float = 0.25,
                 max_portfolio_risk: float = 0.02,
                 use_kelly_sizing: bool = True,
                 kelly_lookback: int = 252,
                 kelly_scaling: float = 0.25):
        """
        Initialize the backtesting engine.
        
        Args:
            initial_capital: Starting capital
            commission_rate: Commission as fraction of trade value
            slippage_rate: Slippage as fraction of trade value
            max_position_size: Maximum position size as fraction of capital
            max_portfolio_risk: Maximum portfolio risk per trade
            use_kelly_sizing: Whether to use Kelly Criterion for position sizing
            kelly_lookback: Lookback period for Kelly calculation
            kelly_scaling: Kelly scaling factor (e.g., 0.25 for quarter Kelly)
        """
        
        self.initial_capital = initial_capital
        self.commission_rate = commission_rate
        self.slippage_rate = slippage_rate
        self.max_position_size = max_position_size
        self.max_portfolio_risk = max_portfolio_risk
        self.use_kelly_sizing = use_kelly_sizing
        self.kelly_lookback = kelly_lookback
        self.kelly_scaling = kelly_scaling
        
        # Portfolio state
        self.cash = initial_capital
        self.positions = {}  # symbol -> Position
        self.portfolio_value = initial_capital
        
        # Trade tracking
        self.trades = []
        self.daily_values = []
        self.daily_returns = []
        
        # Performance tracking
        self.equity_curve = pd.Series(dtype=float)
        self.drawdown_series = pd.Series(dtype=float)
        
    def run_backtest(self, 
                    data: pd.DataFrame, 
                    strategy: BaseStrategy,
                    symbol: str = "STOCK") -> Dict:
        """
        Run a complete backtest for a single symbol.
        
        Args:
            data: DataFrame with OHLCV data and indicators
            strategy: Strategy instance to test
            symbol: Symbol identifier
            
        Returns:
            Dictionary with backtest results
        """
        
        # Reset engine state
        self._reset_engine()
        
        # Generate all signals first
        print("Generating strategy signals...")
        signals = strategy.generate_signals(data)
        
        if not signals:
            print("No signals generated by strategy")
            return self._create_empty_results()
        
        print(f"Generated {len(signals)} signals")
        
        # Create signal lookup for faster access
        signal_dict = {signal.timestamp: signal for signal in signals}
        
        # Initialize tracking
        equity_values = []
        dates = []
        
        print("Running backtest simulation...")
        
        # Simulate trading day by day
        for i, (date, row) in enumerate(data.iterrows()):
            
            current_price = row['Close']
            
            # Update portfolio value
            self._update_portfolio_value(symbol, current_price)
            
            # Check for exits first
            self._check_exits(symbol, current_price, date, row)
            
            # Check for new signals
            if date in signal_dict:
                signal = signal_dict[date]
                self._process_signal(signal, symbol, current_price, date, data.iloc[:i+1])
            
            # Record daily portfolio value
            equity_values.append(self.portfolio_value)
            dates.append(date)
            
            # Progress update
            if i % 252 == 0:  # Every year
                print(f"Progress: {i}/{len(data)} days, Portfolio: ${self.portfolio_value:,.2f}")
        
        # Create equity curve
        self.equity_curve = pd.Series(equity_values, index=dates)
        
        print(f"Backtest completed. Final portfolio value: ${self.portfolio_value:,.2f}")
        print(f"Total trades: {len(self.trades)}")
        
        return self._create_results(data, strategy)
    
    def _process_signal(self, 
                       signal: StrategySignal, 
                       symbol: str, 
                       current_price: float,
                       current_date: pd.Timestamp,
                       historical_data: pd.DataFrame) -> None:
        """Process a trading signal."""
        
        # Check if we already have a position in this symbol
        if symbol in self.positions:
            current_position = self.positions[symbol]
            
            # If signal is opposite to current position, close first
            if ((signal.signal_type == SignalType.BUY and current_position.side == 'short') or
                (signal.signal_type == SignalType.SELL and current_position.side == 'long')):
                self._close_position(symbol, current_price, current_date, "Signal reversal")
        
        # Open new position if signal is not HOLD
        if signal.signal_type in [SignalType.BUY, SignalType.SELL]:
            self._open_position(signal, symbol, current_price, current_date, historical_data)
    
    def _open_position(self, 
                      signal: StrategySignal, 
                      symbol: str, 
                      current_price: float,
                      current_date: pd.Timestamp,
                      historical_data: pd.DataFrame) -> None:
        """Open a new position based on signal."""
        
        # Calculate position size
        position_size = self._calculate_position_size(
            signal, current_price, historical_data
        )
        
        if position_size <= 0:
            return
        
        # Calculate costs
        trade_value = position_size * current_price
        commission = trade_value * self.commission_rate
        slippage = trade_value * self.slippage_rate
        total_cost = trade_value + commission + slippage
        
        # Check if we have enough cash
        if total_cost > self.cash:
            # Reduce position size to fit available cash
            available_for_trade = self.cash * 0.95  # Leave 5% buffer
            position_size = available_for_trade / (current_price * (1 + self.commission_rate + self.slippage_rate))
            
            if position_size <= 0:
                return
            
            trade_value = position_size * current_price
            commission = trade_value * self.commission_rate
            slippage = trade_value * self.slippage_rate
            total_cost = trade_value + commission + slippage
        
        # Execute trade
        self.cash -= total_cost
        
        # Create position
        side = 'long' if signal.signal_type == SignalType.BUY else 'short'
        
        position = Position(
            symbol=symbol,
            side=side,
            quantity=position_size,
            entry_price=current_price,
            entry_time=current_date,
            current_price=current_price,
            unrealized_pnl=0.0,
            stop_loss=signal.stop_loss,
            take_profit=signal.take_profit,
            metadata=signal.metadata
        )
        
        self.positions[symbol] = position
        
        # Update portfolio value
        self._update_portfolio_value(symbol, current_price)
    
    def _close_position(self, 
                       symbol: str, 
                       exit_price: float, 
                       exit_date: pd.Timestamp,
                       exit_reason: str) -> None:
        """Close an existing position."""
        
        if symbol not in self.positions:
            return
        
        position = self.positions[symbol]
        
        # Calculate trade value and costs
        trade_value = position.quantity * exit_price
        commission = trade_value * self.commission_rate
        slippage = trade_value * self.slippage_rate
        
        # Calculate P&L
        if position.side == 'long':
            gross_pnl = (exit_price - position.entry_price) * position.quantity
        else:  # short
            gross_pnl = (position.entry_price - exit_price) * position.quantity
        
        net_pnl = gross_pnl - commission - slippage
        pnl_pct = net_pnl / (position.entry_price * position.quantity)
        
        # Update cash
        if position.side == 'long':
            self.cash += trade_value - commission - slippage
        else:  # short
            # For short positions, we get the initial trade value plus P&L
            self.cash += (position.entry_price * position.quantity) + net_pnl
        
        # Create trade record
        holding_period = (exit_date - position.entry_time).days
        
        trade = Trade(
            entry_time=position.entry_time,
            exit_time=exit_date,
            symbol=symbol,
            side=position.side,
            entry_price=position.entry_price,
            exit_price=exit_price,
            quantity=position.quantity,
            pnl=net_pnl,
            pnl_pct=pnl_pct,
            commission=commission,
            slippage=slippage,
            holding_period=holding_period,
            exit_reason=exit_reason,
            metadata=position.metadata
        )
        
        self.trades.append(trade)
        
        # Remove position
        del self.positions[symbol]
    
    def _check_exits(self, 
                    symbol: str, 
                    current_price: float, 
                    current_date: pd.Timestamp,
                    current_data: pd.Series) -> None:
        """Check if any positions should be exited."""
        
        if symbol not in self.positions:
            return
        
        position = self.positions[symbol]
        
        # Check holding period (if specified in metadata)
        if position.metadata and 'holding_days' in position.metadata:
            holding_days = position.metadata['holding_days']
            days_held = (current_date - position.entry_time).days
            if days_held >= holding_days:
                self._close_position(symbol, current_price, current_date, f"Holding period ({holding_days} days)")
                return
        
        # Check stop loss
        if position.stop_loss is not None:
            if ((position.side == 'long' and current_price <= position.stop_loss) or
                (position.side == 'short' and current_price >= position.stop_loss)):
                self._close_position(symbol, current_price, current_date, "Stop loss")
                return
        
        # Check take profit
        if position.take_profit is not None:
            if ((position.side == 'long' and current_price >= position.take_profit) or
                (position.side == 'short' and current_price <= position.take_profit)):
                self._close_position(symbol, current_price, current_date, "Take profit")
                return
    
    def _calculate_position_size(self, 
                               signal: StrategySignal, 
                               current_price: float,
                               historical_data: pd.DataFrame) -> float:
        """Calculate position size using Kelly Criterion or fixed sizing."""
        
        if not self.use_kelly_sizing:
            # Fixed percentage sizing
            return (self.portfolio_value * self.max_position_size) / current_price
        
        # Kelly Criterion sizing
        kelly_fraction = self._calculate_kelly_fraction(historical_data)
        
        # Apply scaling and limits
        scaled_kelly = kelly_fraction * self.kelly_scaling
        position_fraction = min(scaled_kelly, self.max_position_size)
        position_fraction = max(position_fraction, 0.01)  # Minimum 1%
        
        return (self.portfolio_value * position_fraction) / current_price
    
    def _calculate_kelly_fraction(self, historical_data: pd.DataFrame) -> float:
        """Calculate Kelly fraction from historical returns."""
        
        if len(self.trades) < 10:  # Need minimum trade history
            return 0.1  # Default 10%
        
        # Get recent trades for Kelly calculation
        recent_trades = self.trades[-min(len(self.trades), self.kelly_lookback):]
        
        if not recent_trades:
            return 0.1
        
        # Calculate win rate and average win/loss
        returns = [trade.pnl_pct for trade in recent_trades]
        wins = [r for r in returns if r > 0]
        losses = [r for r in returns if r < 0]
        
        if len(wins) == 0 or len(losses) == 0:
            return 0.1
        
        win_rate = len(wins) / len(returns)
        avg_win = np.mean(wins)
        avg_loss = abs(np.mean(losses))
        
        if avg_loss == 0:
            return 0.1
        
        # Kelly formula: f = (bp - q) / b
        b = avg_win / avg_loss  # odds
        p = win_rate
        q = 1 - win_rate
        
        kelly_fraction = (b * p - q) / b
        
        return max(0.01, min(0.5, kelly_fraction))  # Limit between 1% and 50%
    
    def _update_portfolio_value(self, symbol: str, current_price: float) -> None:
        """Update portfolio value based on current prices."""
        
        total_value = self.cash
        
        # Add value of open positions
        if symbol in self.positions:
            position = self.positions[symbol]
            position.current_price = current_price
            
            if position.side == 'long':
                position_value = position.quantity * current_price
                unrealized_pnl = (current_price - position.entry_price) * position.quantity
            else:  # short
                position_value = position.quantity * position.entry_price  # Initial margin
                unrealized_pnl = (position.entry_price - current_price) * position.quantity
            
            position.unrealized_pnl = unrealized_pnl
            total_value += position_value + unrealized_pnl
        
        self.portfolio_value = total_value
    
    def _reset_engine(self) -> None:
        """Reset engine state for new backtest."""
        
        self.cash = self.initial_capital
        self.positions = {}
        self.portfolio_value = self.initial_capital
        self.trades = []
        self.daily_values = []
        self.daily_returns = []
        self.equity_curve = pd.Series(dtype=float)
        self.drawdown_series = pd.Series(dtype=float)
    
    def _create_results(self, data: pd.DataFrame, strategy: BaseStrategy) -> Dict:
        """Create comprehensive backtest results."""
        
        if len(self.equity_curve) == 0:
            return self._create_empty_results()
        
        # Calculate returns
        returns = self.equity_curve.pct_change().dropna()
        
        # Basic performance metrics
        total_return = (self.portfolio_value / self.initial_capital - 1) * 100
        
        if len(returns) > 0:
            annualized_return = (1 + returns.mean()) ** 252 - 1
            volatility = returns.std() * np.sqrt(252)
            sharpe_ratio = annualized_return / volatility if volatility > 0 else 0
        else:
            annualized_return = 0
            volatility = 0
            sharpe_ratio = 0
        
        # Drawdown calculation
        peak = self.equity_curve.expanding().max()
        drawdown = (self.equity_curve - peak) / peak
        max_drawdown = drawdown.min() * 100
        
        # Trade statistics
        if self.trades:
            winning_trades = [t for t in self.trades if t.pnl > 0]
            losing_trades = [t for t in self.trades if t.pnl < 0]
            
            win_rate = len(winning_trades) / len(self.trades) * 100
            avg_win = np.mean([t.pnl_pct for t in winning_trades]) * 100 if winning_trades else 0
            avg_loss = np.mean([t.pnl_pct for t in losing_trades]) * 100 if losing_trades else 0
            profit_factor = abs(avg_win / avg_loss) if avg_loss != 0 else float('inf')
            
            avg_holding_period = np.mean([t.holding_period for t in self.trades])
        else:
            win_rate = 0
            avg_win = 0
            avg_loss = 0
            profit_factor = 0
            avg_holding_period = 0
        
        return {
            'strategy_name': strategy.name,
            'start_date': data.index[0],
            'end_date': data.index[-1],
            'initial_capital': self.initial_capital,
            'final_value': self.portfolio_value,
            'total_return_pct': total_return,
            'annualized_return_pct': annualized_return * 100,
            'volatility_pct': volatility * 100,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown_pct': max_drawdown,
            'total_trades': len(self.trades),
            'winning_trades': len([t for t in self.trades if t.pnl > 0]),
            'losing_trades': len([t for t in self.trades if t.pnl < 0]),
            'win_rate_pct': win_rate,
            'avg_win_pct': avg_win,
            'avg_loss_pct': avg_loss,
            'profit_factor': profit_factor,
            'avg_holding_period_days': avg_holding_period,
            'equity_curve': self.equity_curve,
            'drawdown_series': drawdown,
            'trades': self.trades,
            'returns': returns
        }
    
    def _create_empty_results(self) -> Dict:
        """Create empty results structure."""
        
        return {
            'strategy_name': 'Unknown',
            'total_return_pct': 0,
            'sharpe_ratio': 0,
            'max_drawdown_pct': 0,
            'total_trades': 0,
            'win_rate_pct': 0,
            'equity_curve': pd.Series(dtype=float),
            'trades': []
        }
    
    def get_trade_analysis(self) -> pd.DataFrame:
        """Get detailed trade analysis as DataFrame."""
        
        if not self.trades:
            return pd.DataFrame()
        
        trade_data = []
        for trade in self.trades:
            trade_data.append({
                'Entry Time': trade.entry_time,
                'Exit Time': trade.exit_time,
                'Symbol': trade.symbol,
                'Side': trade.side,
                'Entry Price': trade.entry_price,
                'Exit Price': trade.exit_price,
                'Quantity': trade.quantity,
                'P&L': trade.pnl,
                'P&L %': trade.pnl_pct * 100,
                'Commission': trade.commission,
                'Slippage': trade.slippage,
                'Holding Period': trade.holding_period,
                'Exit Reason': trade.exit_reason
            })
        
        return pd.DataFrame(trade_data)
    
    def get_monthly_returns(self) -> pd.DataFrame:
        """Get monthly returns breakdown."""
        
        if len(self.equity_curve) == 0:
            return pd.DataFrame()
        
        monthly_values = self.equity_curve.resample('M').last()
        monthly_returns = monthly_values.pct_change().dropna()
        
        # Create monthly returns table
        monthly_df = pd.DataFrame({
            'Month': monthly_returns.index.strftime('%Y-%m'),
            'Return %': monthly_returns.values * 100
        })
        
        return monthly_df